//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

#include "./midifile/MidiFile.h"

// general includes
#include <stdio.h>
#include <limits.h>

#include <random>
#include <string>
#include <fstream>
#include <iostream>

// declaration of chugin constructor
CK_DLL_CTOR(MarkovGenerator_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(MarkovGenerator_dtor);

CK_DLL_MFUN(MarkovGenerator_loadMidi);
CK_DLL_MFUN(MarkovGenerator_next);
CK_DLL_MFUN(MarkovGenerator_setLast);
CK_DLL_MFUN(MarkovGenerator_printMatrix);
CK_DLL_MFUN(MarkovGenerator_setSeed);
CK_DLL_MFUN(MarkovGenerator_getSeed);
CK_DLL_MFUN(MarkovGenerator_setOrder);
CK_DLL_MFUN(MarkovGenerator_getOrder);


// this is a special offset reserved for Chugin internal data
t_CKINT MarkovGenerator_data_offset = 0;


// class definition for internal Chugin data
// (note: this isn't strictly necessary, but serves as example
// of one recommended approach)
//
class MarkovGenerator
{
public:

	MarkovGenerator(t_CKINT note = 0) : order(0), seq(), seq_pos(-1), probabilities1(),probabilities2(), probabilities3(), last_note(note%12), octave(note/12), seed(std::random_device{}()) {}


	void loadMidi(std::string midi_file = "test.mid") 
	{
		smf::MidiFile midifile;
		midifile.read(midi_file);
		
		if (!midifile.status()) 
		{
			std::cout << "bad file name" << std::endl;
			return;
		}
		midifile.joinTracks();
		int track = 0;
		int last[4] = {};
		int i = 0;
		int left_to_start = 4;
		for (i; left_to_start > 0 && i < midifile[track].size(); i++) {
			if (midifile[track][i].isNoteOn()) {
				switch (left_to_start) {
					case 4:
						last[3] = midifile[track][i];
						break;
					case 3:
						last[2] = midifile[track][i];
						probabilities1[last[3]][last[2]] += 1;
						break;
					case 2:
						last[1] = midifile[track][i];
						probabilities2[last[3]][last[2]][last[1]] += 1;
						break;
					case 1:
						last[0] = midifile[track][i];
						probabilities3[last[3]][last[2]][last[1]][last[0]] += 1;
						break;
				}
				left_to_start--;
			}
		}

		for (i; i < midifile[track].size(); i++) {
			if (midifile[track][i].isNoteOn()) {
				last[0] = midifile[track][i][1] % 12;
				probabilities1[last[1]][last[0]] += 1;
				probabilities2[last[2]][last[1]][last[0]] += 1;
				probabilities3[last[3]][last[2]][last[1]][last[0]] += 1;
				last[3] = last[2];
				last[2] = last[1];
				last[1] = last[0];
			}
		}
	}

	t_CKINT next()
	{
		if (seq_pos > 0) {
			seq_pos--;
			return seq[seq_pos + 1] + (12 * octave);
		}
		int cur_order = order;
		if (!order) {
			std::uniform_int_distribution<std::mt19937::result_type> gen(1, 3);
			cur_order = gen(rng);
		}
		switch (cur_order) {
			case 1:	
			{	
				std::uniform_int_distribution<std::mt19937::result_type> gen(0, getCeiling(last_note, 1));
				int rng_result = gen(rng);
				char i = 0;
				for (int total = 0; total < rng_result; i++) { total += probabilities1[last_note][i]; }
				last_note = i;
				return last_note + (12 * octave);
			}
			case 2:
			{
				std::uniform_int_distribution<std::mt19937::result_type> gen(0, getCeiling(last_note, 2));
				int rng_result = gen(rng);
				char i = 0;
				for (int total = 0; total < rng_result; i++) { 
					total += probabilities2[last_note][i/12][i%12]; 
				}
				seq[0] = i%12;
				seq_pos = 0;
				last_note = i/12;
				return last_note + (12 * octave);
			}
			case 3:
			{
				std::uniform_int_distribution<std::mt19937::result_type> gen(0, getCeiling(last_note, 3));
				int rng_result = gen(rng);
				char i = 0;
				for (int total = 0; total < rng_result; i++) { 
					total += probabilities3[last_note][i/144][(i%144)/12][i%12]; 
				}
				seq[0] = (i%144)/12;
				seq[1] = i%12;
				seq_pos = 1;
				last_note = i/144;
				return last_note + (12 * octave);
			}
		}
		return 0;

	}

	t_CKINT getOrder() { return order; }

	t_CKINT setOrder(t_CKINT new_order)
	{
		order = new_order;
		return new_order;
	}

	t_CKINT next(t_CKINT cur_note)
	{
		setLast(cur_note);
		return next();
	}

	t_CKINT getSeed() { return seed; }
	
	t_CKINT setSeed(t_CKINT new_seed)
	{
		seed = new_seed;
		rng.seed(seed);
		return new_seed;
	}

	t_CKINT setLast(t_CKINT note) 
	{
		octave = note / 12;
		last_note = note % 12;
		return note;
	}


	void printMatrix() 
	{
		for (int i = 0; i < 12; i++) {
			for (int j = 0; j < 12; j++) {
				std::cout << probabilities1[i][j] << " ";
			}
			std::cout << std::endl;
		}
	}
	
private:
	// instance data
	t_CKINT seed;
	std::mt19937 rng;
	t_CKINT octave;
	int probabilities1[12][12];
	int probabilities2[12][12][12];
	int probabilities3[12][12][12][12];
	int seq[2];
	int seq_pos;
	int order;
	t_CKINT last_note;

	int getCeiling(int note, int chain_order = 1) 
	{
		int random_ceiling = 0;
		switch(chain_order) {	
			case 1:
				for (int i = 0; i < 12; i++) 
					random_ceiling += probabilities1[note%12][i];
				break;
			case 2:
				for (int i = 0; i < 12; i++)
					for (int j = 0; j < 12; j++)
						random_ceiling += probabilities2[note%12][i][j];
			case 3:
				for (int i = 0; i < 12; i++)
					for (int j = 0; j < 12; j ++)
						for (int k = 0; k < 12; k++)
							random_ceiling += probabilities3[note%12][i][j][k];

		}
		return random_ceiling;
	}
};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( MarkovGenerator )
{
	// hmm, don't change this...
	QUERY->setname(QUERY, "MarkovGenerator");
	
	// begin the class definition
	// can change the second argument to extend a different ChucK class
	QUERY->begin_class(QUERY, "MarkovGenerator", "UGen");

	// register the constructor (probably no need to change)
	QUERY->add_ctor(QUERY, MarkovGenerator_ctor);
	// register the destructor (probably no need to change)
	QUERY->add_dtor(QUERY, MarkovGenerator_dtor);
	
	
	// NOTE: if this is to be a UGen with more than 1 channel, 
	// e.g., a multichannel UGen -- will need to use add_ugen_funcf()
	// and declare a tickf function using CK_DLL_TICKF

	QUERY->add_mfun(QUERY, MarkovGenerator_loadMidi, "void", "loadMidi");
	QUERY->add_arg(QUERY, "string", "arg");

	QUERY->add_mfun(QUERY, MarkovGenerator_printMatrix, "void", "printMatrix");
	QUERY->add_mfun(QUERY, MarkovGenerator_next, "int", "next");

	QUERY->add_mfun(QUERY, MarkovGenerator_setLast, "int", "last");
	QUERY->add_arg(QUERY, "int", "arg");

	QUERY->add_mfun(QUERY, MarkovGenerator_setSeed, "int", "seed");
	QUERY->add_arg(QUERY, "int", "arg");

	QUERY->add_mfun(QUERY, MarkovGenerator_getSeed, "int", "seed");

	QUERY->add_mfun(QUERY, MarkovGenerator_setOrder, "int", "order");
	QUERY->add_arg(QUERY, "int", "arg");

	QUERY->add_mfun(QUERY, MarkovGenerator_getOrder, "int", "order");

	// this reserves a variable in the ChucK internal class to store 
	// referene to the c++ class we defined above
	MarkovGenerator_data_offset = QUERY->add_mvar(QUERY, "int", "@m_data", false);

	// end the class definition
	// IMPORTANT: this MUST be called!
	QUERY->end_class(QUERY);

	// wasn't that a breeze?
	return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(MarkovGenerator_ctor)
{
	// get the offset where we'll store our internal c++ class pointer
	OBJ_MEMBER_INT(SELF, MarkovGenerator_data_offset) = 0;
	
	// instantiate our internal c++ class representation
	MarkovGenerator * m_obj = new MarkovGenerator();
	
	// set the seed
	m_obj -> setSeed(m_obj -> getSeed());
	
	// store the pointer in the ChucK object member
	OBJ_MEMBER_INT(SELF, MarkovGenerator_data_offset) = (t_CKINT) m_obj;
}


// implementation for the destructor
CK_DLL_DTOR(MarkovGenerator_dtor)
{
	// get our c++ class pointer
	MarkovGenerator * m_obj = (MarkovGenerator *) OBJ_MEMBER_INT(SELF, MarkovGenerator_data_offset);
	// check it
	if( m_obj )
	{
		// clean up
		delete m_obj;
		OBJ_MEMBER_INT(SELF, MarkovGenerator_data_offset) = 0;
		m_obj = NULL;
	}
}

CK_DLL_MFUN(MarkovGenerator_loadMidi)
{
	// get our c++ class pointer
	MarkovGenerator * m_obj = (MarkovGenerator *) OBJ_MEMBER_INT(SELF, MarkovGenerator_data_offset);
	m_obj->loadMidi(GET_NEXT_STRING_SAFE(ARGS));
}

CK_DLL_MFUN(MarkovGenerator_printMatrix)
{
	// get our c++ class pointer
	MarkovGenerator * m_obj = (MarkovGenerator *) OBJ_MEMBER_INT(SELF, MarkovGenerator_data_offset);
	m_obj->printMatrix();
}

CK_DLL_MFUN(MarkovGenerator_setLast)
{
	// get our c++ class pointer
	MarkovGenerator * m_obj = (MarkovGenerator *) OBJ_MEMBER_INT(SELF, MarkovGenerator_data_offset);
	// set the return value
	RETURN->v_int = m_obj->setLast(GET_NEXT_INT(ARGS));
}

CK_DLL_MFUN(MarkovGenerator_setOrder)
{
	// get our c++ class pointer
	MarkovGenerator * m_obj = (MarkovGenerator *) OBJ_MEMBER_INT(SELF, MarkovGenerator_data_offset);
	// set the return value
	RETURN->v_int = m_obj->setOrder(GET_NEXT_INT(ARGS));
}

CK_DLL_MFUN(MarkovGenerator_setSeed)
{
	// get our c++ class pointer
	MarkovGenerator * m_obj = (MarkovGenerator *) OBJ_MEMBER_INT(SELF, MarkovGenerator_data_offset);
	// set the return value
	RETURN->v_int = m_obj->setSeed(GET_NEXT_INT(ARGS));
}

CK_DLL_MFUN(MarkovGenerator_next)
{
	// get our c++ class pointer
	MarkovGenerator * m_obj = (MarkovGenerator *) OBJ_MEMBER_INT(SELF, MarkovGenerator_data_offset);
	// set the return value
	RETURN->v_int = m_obj->next();
}

CK_DLL_MFUN(MarkovGenerator_getOrder)
{
	// get our c++ class pointer
	MarkovGenerator * m_obj = (MarkovGenerator *) OBJ_MEMBER_INT(SELF, MarkovGenerator_data_offset);
	// set the return value
	RETURN->v_int = m_obj->getOrder();
}

CK_DLL_MFUN(MarkovGenerator_getSeed)
{
	// get our c++ class pointer
	MarkovGenerator * m_obj = (MarkovGenerator *) OBJ_MEMBER_INT(SELF, MarkovGenerator_data_offset);
	// set the return value
	RETURN->v_int = m_obj->getSeed();
}
